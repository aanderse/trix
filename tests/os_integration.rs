//! Integration tests for `trix os rebuild`.
//!
//! Tests the NixOS system management command that generates Nix expressions
//! for nixos-rebuild without copying the local flake to the store.

use std::fs;
use std::process::Command;

/// Get the path to the trix binary.
fn trix_bin() -> String {
    std::env::var("CARGO_BIN_EXE_trix").unwrap_or_else(|_| "target/debug/trix".to_string())
}

/// Run trix os rebuild with --print-expr and return the generated expression.
fn trix_os_print_expr(args: &[&str]) -> Result<String, String> {
    let output = Command::new(trix_bin())
        .args(["os", "rebuild"])
        .args(args)
        .arg("--print-expr")
        .output()
        .map_err(|e| format!("failed to run trix: {}", e))?;

    if !output.status.success() {
        return Err(String::from_utf8_lossy(&output.stderr).to_string());
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Create a minimal NixOS flake for testing.
/// Returns the temp directory (must be kept alive for the duration of the test).
fn create_test_nixos_flake() -> (tempfile::TempDir, String) {
    let temp_dir = tempfile::TempDir::new().expect("failed to create temp dir");
    let flake_dir = temp_dir.path();
    let hostname = "testhost";

    // Create a minimal NixOS flake
    let flake_nix = r#"{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };

  outputs = { self, nixpkgs }: {
    nixosConfigurations.testhost = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
      modules = [
        ({ ... }: {
          # Minimal configuration for testing
          boot.loader.grub.enable = false;
          fileSystems."/" = {
            device = "/dev/null";
            fsType = "tmpfs";
          };
          system.stateVersion = "24.05";
        })
      ];
    };
  };
}"#;
    fs::write(flake_dir.join("flake.nix"), flake_nix).expect("failed to write flake.nix");

    // Lock the flake using nix (more reliable than trix for this purpose)
    let nix_lock = Command::new("nix")
        .args(["flake", "lock"])
        .current_dir(flake_dir)
        .output()
        .expect("failed to run nix flake lock");

    assert!(
        nix_lock.status.success(),
        "failed to lock flake: {}",
        String::from_utf8_lossy(&nix_lock.stderr)
    );

    (temp_dir, hostname.to_string())
}

// =============================================================================
// Expression Generation Tests
// =============================================================================

#[test]
fn os_rebuild_print_expr_generates_valid_nix() {
    let (temp_dir, hostname) = create_test_nixos_flake();
    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    let result = trix_os_print_expr(&["build", "--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Verify it contains expected components
    assert!(
        expr.contains("# Generated by trix for NixOS rebuild"),
        "missing header comment"
    );
    assert!(
        expr.contains(&format!("Host: {}", hostname)),
        "missing hostname in header"
    );
    assert!(
        expr.contains("flakeDirPath"),
        "missing flakeDirPath binding"
    );
    assert!(
        expr.contains("nixosConfigurations"),
        "missing nixosConfigurations in output"
    );
    assert!(
        expr.contains(&hostname),
        "missing hostname in expression"
    );
}

#[test]
fn os_rebuild_print_expr_can_be_parsed_by_nix() {
    let (temp_dir, hostname) = create_test_nixos_flake();
    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    let result = trix_os_print_expr(&["build", "--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Write expression to a temp file
    let expr_file = temp_dir.path().join("test-expr.nix");
    fs::write(&expr_file, &expr).expect("failed to write expression file");

    // Try to parse it with nix-instantiate --parse
    let parse_output = Command::new("nix-instantiate")
        .args(["--parse", expr_file.to_str().unwrap()])
        .output()
        .expect("failed to run nix-instantiate");

    assert!(
        parse_output.status.success(),
        "nix-instantiate --parse failed:\nExpression:\n{}\n\nError:\n{}",
        expr,
        String::from_utf8_lossy(&parse_output.stderr)
    );
}

#[test]
fn os_rebuild_print_expr_evaluates_to_nixos_config() {
    let (temp_dir, hostname) = create_test_nixos_flake();
    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    let result = trix_os_print_expr(&["build", "--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Write expression to a temp file
    let expr_file = temp_dir.path().join("test-expr.nix");
    fs::write(&expr_file, &expr).expect("failed to write expression file");

    // Try to evaluate config.system.build.toplevel (what nixos-rebuild would access)
    // We use --eval to avoid actually building anything
    let eval_output = Command::new("nix-instantiate")
        .args([
            "--eval",
            "--strict",
            expr_file.to_str().unwrap(),
            "-A",
            "config.system.build.toplevel.drvPath",
        ])
        .output()
        .expect("failed to run nix-instantiate");

    assert!(
        eval_output.status.success(),
        "Failed to evaluate config.system.build.toplevel:\nExpression file: {}\n\nError:\n{}",
        expr_file.display(),
        String::from_utf8_lossy(&eval_output.stderr)
    );

    let drv_path = String::from_utf8_lossy(&eval_output.stdout);
    assert!(
        drv_path.contains("/nix/store/") && drv_path.contains(".drv"),
        "Expected derivation path, got: {}",
        drv_path
    );
}

// =============================================================================
// Hostname Resolution Tests
// =============================================================================

#[test]
fn os_rebuild_uses_system_hostname_when_not_specified() {
    let (temp_dir, _) = create_test_nixos_flake();

    // Create a flake with the system's actual hostname
    let system_hostname = hostname::get()
        .expect("failed to get hostname")
        .into_string()
        .expect("hostname not utf8");

    // Rewrite flake.nix with system hostname
    let flake_nix = format!(
        r#"{{
  inputs = {{
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  }};

  outputs = {{ self, nixpkgs }}: {{
    nixosConfigurations."{hostname}" = nixpkgs.lib.nixosSystem {{
      system = "x86_64-linux";
      modules = [
        ({{ ... }}: {{
          boot.loader.grub.enable = false;
          fileSystems."/" = {{
            device = "/dev/null";
            fsType = "tmpfs";
          }};
          system.stateVersion = "24.05";
        }})
      ];
    }};
  }};
}}"#,
        hostname = system_hostname
    );
    fs::write(temp_dir.path().join("flake.nix"), flake_nix).expect("failed to write flake.nix");

    // Re-lock
    let _ = Command::new("nix")
        .args(["flake", "lock"])
        .current_dir(temp_dir.path())
        .output();

    // Run without specifying hostname - should use system hostname
    let flake_ref = format!("{}", temp_dir.path().display());
    let result = trix_os_print_expr(&["build", "--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();
    assert!(
        expr.contains(&format!("Host: {}", system_hostname)),
        "Should use system hostname '{}' in header, got:\n{}",
        system_hostname,
        expr.lines().take(5).collect::<Vec<_>>().join("\n")
    );
}

// =============================================================================
// Store Copy Prevention Tests
// =============================================================================

#[test]
fn os_rebuild_expr_does_not_copy_flake_to_store() {
    use uuid::Uuid;

    // Create a unique identifier
    let uuid = Uuid::new_v4().to_string();
    let marker_filename = format!("trix-os-marker-{}.txt", uuid);

    let (temp_dir, hostname) = create_test_nixos_flake();

    // Create a marker file in the flake directory
    fs::write(temp_dir.path().join(&marker_filename), "marker content")
        .expect("failed to write marker file");

    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    // Generate the expression
    let result = trix_os_print_expr(&["build", "--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Write and evaluate the expression (this triggers any store copies)
    let expr_file = temp_dir.path().join("test-expr.nix");
    fs::write(&expr_file, &expr).expect("failed to write expression file");

    // Evaluate with nix-instantiate (triggers fetching/copying)
    let _ = Command::new("nix-instantiate")
        .args(["--eval", expr_file.to_str().unwrap()])
        .output();

    // Now verify the marker file is NOT in the nix store
    let find_output = Command::new("find")
        .args([
            "/nix/store",
            "-maxdepth",
            "2",
            "-name",
            &format!("*{}*", &uuid),
        ])
        .output()
        .expect("failed to run find");

    let found_paths = String::from_utf8_lossy(&find_output.stdout);
    assert!(
        found_paths.trim().is_empty(),
        "FAIL: trix os copied flake to store! Found paths containing UUID:\n{}",
        found_paths
    );
}

// =============================================================================
// Expression Content Tests
// =============================================================================

#[test]
fn os_rebuild_expr_uses_local_path_directly() {
    let (temp_dir, hostname) = create_test_nixos_flake();
    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    let result = trix_os_print_expr(&["build", "--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();
    let flake_path = temp_dir.path().display().to_string();

    // Verify the expression references the local path directly (not a store path)
    assert!(
        expr.contains(&format!("flakeDirPath = {}", flake_path)),
        "Expression should reference local path directly.\nExpected: flakeDirPath = {}\nGot:\n{}",
        flake_path,
        expr.lines()
            .filter(|l| l.contains("flakeDirPath"))
            .collect::<Vec<_>>()
            .join("\n")
    );

    // Verify it does NOT use builtins.getFlake for the local flake
    assert!(
        !expr.contains("builtins.getFlake"),
        "Expression should NOT use builtins.getFlake (that would copy to store)"
    );
}

#[test]
fn os_rebuild_expr_fetches_remote_inputs() {
    let (temp_dir, hostname) = create_test_nixos_flake();
    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    let result = trix_os_print_expr(&["build", "--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Verify nixpkgs is fetched via builtins.fetchTarball (this is fine for remote inputs)
    assert!(
        expr.contains("builtins.fetchTarball"),
        "Expression should fetch remote inputs via builtins.fetchTarball"
    );

    assert!(
        expr.contains("nixpkgs") || expr.contains("NixOS/nixpkgs"),
        "Expression should reference nixpkgs input"
    );
}

// =============================================================================
// CLI Argument Tests
// =============================================================================

#[test]
fn os_rebuild_help_shows_all_actions() {
    let output = Command::new(trix_bin())
        .args(["os", "rebuild", "--help"])
        .output()
        .expect("failed to run trix");

    let help_text = String::from_utf8_lossy(&output.stdout);

    assert!(help_text.contains("switch"), "missing switch action");
    assert!(help_text.contains("boot"), "missing boot action");
    assert!(help_text.contains("test"), "missing test action");
    assert!(help_text.contains("build"), "missing build action");
    assert!(help_text.contains("dry-build"), "missing dry-build action");
    assert!(help_text.contains("build-vm"), "missing build-vm action");
}

#[test]
fn os_rebuild_requires_flake_lock() {
    let temp_dir = tempfile::TempDir::new().expect("failed to create temp dir");

    // Create flake.nix but NO flake.lock
    let flake_nix = r#"{
  inputs = { };
  outputs = { self }: {
    nixosConfigurations.test = { };
  };
}"#;
    fs::write(temp_dir.path().join("flake.nix"), flake_nix).expect("failed to write flake.nix");

    let flake_ref = format!("{}#test", temp_dir.path().display());
    let result = trix_os_print_expr(&["build", "--flake", &flake_ref]);

    assert!(result.is_err(), "should fail without flake.lock");
    let err = result.unwrap_err();
    assert!(
        err.contains("flake.lock") || err.contains("lock"),
        "error should mention flake.lock: {}",
        err
    );
}

// =============================================================================
// REPL Tests
// =============================================================================

/// Run trix os repl with --print-expr and return the generated expression.
fn trix_os_repl_print_expr(args: &[&str]) -> Result<String, String> {
    let output = Command::new(trix_bin())
        .args(["os", "repl"])
        .args(args)
        .arg("--print-expr")
        .output()
        .map_err(|e| format!("failed to run trix: {}", e))?;

    if !output.status.success() {
        return Err(String::from_utf8_lossy(&output.stderr).to_string());
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

#[test]
fn os_repl_print_expr_generates_valid_nix() {
    let (temp_dir, hostname) = create_test_nixos_flake();
    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    let result = trix_os_repl_print_expr(&["--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Verify it contains expected REPL-specific components
    assert!(
        expr.contains("# NixOS REPL - generated by trix"),
        "missing REPL header comment"
    );
    assert!(
        expr.contains(&format!("Host: {}", hostname)),
        "missing hostname in header"
    );
    assert!(
        expr.contains("Available variables:"),
        "missing available variables comment"
    );
    assert!(expr.contains("config"), "missing config variable");
    assert!(expr.contains("options"), "missing options variable");
    assert!(expr.contains("pkgs"), "missing pkgs variable");
    assert!(expr.contains("lib"), "missing lib variable");
}

#[test]
fn os_repl_print_expr_can_be_parsed_by_nix() {
    let (temp_dir, hostname) = create_test_nixos_flake();
    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    let result = trix_os_repl_print_expr(&["--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Write expression to a temp file
    let expr_file = temp_dir.path().join("test-repl-expr.nix");
    fs::write(&expr_file, &expr).expect("failed to write expression file");

    // Try to parse it with nix-instantiate --parse
    let parse_output = Command::new("nix-instantiate")
        .args(["--parse", expr_file.to_str().unwrap()])
        .output()
        .expect("failed to run nix-instantiate");

    assert!(
        parse_output.status.success(),
        "nix-instantiate --parse failed:\nExpression:\n{}\n\nError:\n{}",
        expr,
        String::from_utf8_lossy(&parse_output.stderr)
    );
}

#[test]
fn os_repl_expr_exposes_config_options_pkgs_lib() {
    let (temp_dir, hostname) = create_test_nixos_flake();
    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    let result = trix_os_repl_print_expr(&["--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Write expression to a temp file
    let expr_file = temp_dir.path().join("test-repl-expr.nix");
    fs::write(&expr_file, &expr).expect("failed to write expression file");

    // Verify we can access config.system.stateVersion
    let eval_config = Command::new("nix-instantiate")
        .args([
            "--eval",
            "--strict",
            expr_file.to_str().unwrap(),
            "-A",
            "config.system.stateVersion",
        ])
        .output()
        .expect("failed to run nix-instantiate");

    assert!(
        eval_config.status.success(),
        "Failed to evaluate config.system.stateVersion:\n{}",
        String::from_utf8_lossy(&eval_config.stderr)
    );

    let state_version = String::from_utf8_lossy(&eval_config.stdout);
    assert!(
        state_version.contains("24.05"),
        "Expected stateVersion 24.05, got: {}",
        state_version
    );

    // Verify we can access pkgs
    let eval_pkgs = Command::new("nix-instantiate")
        .args([
            "--eval",
            "--strict",
            expr_file.to_str().unwrap(),
            "-A",
            "pkgs.hello.name",
        ])
        .output()
        .expect("failed to run nix-instantiate");

    assert!(
        eval_pkgs.status.success(),
        "Failed to evaluate pkgs.hello.name:\n{}",
        String::from_utf8_lossy(&eval_pkgs.stderr)
    );

    let hello_name = String::from_utf8_lossy(&eval_pkgs.stdout);
    assert!(
        hello_name.contains("hello"),
        "Expected hello package name, got: {}",
        hello_name
    );
}

#[test]
fn os_repl_expr_does_not_copy_flake_to_store() {
    use uuid::Uuid;

    // Create a unique identifier
    let uuid = Uuid::new_v4().to_string();
    let marker_filename = format!("trix-repl-marker-{}.txt", uuid);

    let (temp_dir, hostname) = create_test_nixos_flake();

    // Create a marker file in the flake directory
    fs::write(temp_dir.path().join(&marker_filename), "marker content")
        .expect("failed to write marker file");

    let flake_ref = format!("{}#{}", temp_dir.path().display(), hostname);

    // Generate the expression
    let result = trix_os_repl_print_expr(&["--flake", &flake_ref]);
    assert!(result.is_ok(), "print-expr failed: {:?}", result);

    let expr = result.unwrap();

    // Write and evaluate the expression (this triggers any store copies)
    let expr_file = temp_dir.path().join("test-repl-expr.nix");
    fs::write(&expr_file, &expr).expect("failed to write expression file");

    // Evaluate with nix-instantiate (triggers fetching/copying)
    let _ = Command::new("nix-instantiate")
        .args(["--eval", expr_file.to_str().unwrap()])
        .output();

    // Now verify the marker file is NOT in the nix store
    let find_output = Command::new("find")
        .args([
            "/nix/store",
            "-maxdepth",
            "2",
            "-name",
            &format!("*{}*", &uuid),
        ])
        .output()
        .expect("failed to run find");

    let found_paths = String::from_utf8_lossy(&find_output.stdout);
    assert!(
        found_paths.trim().is_empty(),
        "FAIL: trix os repl copied flake to store! Found paths containing UUID:\n{}",
        found_paths
    );
}

#[test]
fn os_repl_help_shows_options() {
    let output = Command::new(trix_bin())
        .args(["os", "repl", "--help"])
        .output()
        .expect("failed to run trix");

    let help_text = String::from_utf8_lossy(&output.stdout);

    assert!(help_text.contains("--flake"), "missing --flake option");
    assert!(help_text.contains("--file"), "missing --file option");
    assert!(help_text.contains("--attr"), "missing --attr option");
    assert!(help_text.contains("--show-trace"), "missing --show-trace option");
    assert!(help_text.contains("--print-expr"), "missing --print-expr option");
}

#[test]
fn os_repl_requires_flake_lock() {
    let temp_dir = tempfile::TempDir::new().expect("failed to create temp dir");

    // Create flake.nix but NO flake.lock
    let flake_nix = r#"{
  inputs = { };
  outputs = { self }: {
    nixosConfigurations.test = { };
  };
}"#;
    fs::write(temp_dir.path().join("flake.nix"), flake_nix).expect("failed to write flake.nix");

    let flake_ref = format!("{}#test", temp_dir.path().display());
    let result = trix_os_repl_print_expr(&["--flake", &flake_ref]);

    assert!(result.is_err(), "should fail without flake.lock");
    let err = result.unwrap_err();
    assert!(
        err.contains("flake.lock") || err.contains("lock"),
        "error should mention flake.lock: {}",
        err
    );
}
